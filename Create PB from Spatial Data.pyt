# -*- coding: utf-8 -*-# -*- coding: utf-8 -*-import arcpyimport osfrom os.path import expanduser, existsimport pandas as pd# tool box developed by grace alston, summer '22class Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [Tool]class Tool(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Dissolve and Upload"        self.description = "A toolbox that takes your selected tax parcels, dissolves them, and uploads them to your program's boundary and feature layers (found in Portal > My Organization)."        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        in_features = arcpy.Parameter(            displayName="Input Features",            name="in_features",            datatype="GPFeatureLayer",            parameterType="Required",            direction="Input")        temp_tax_layer = arcpy.Parameter(            displayName="Temporary Tax Parcels Layer",            name="temp_tax_features",            datatype="GPFeatureLayer",            parameterType="Derived",            direction="Output")        program_boundary_layer = arcpy.Parameter(            displayName="Output Program Boundary Feature Layer",            name="out_pb_features",            datatype="GPFeatureLayer",            parameterType="Optional",            direction="Input")        program_tax_layer = arcpy.Parameter(            displayName="Output Tax Feature Layer",            name="out_tax_parcels",            datatype="GPFeatureLayer",            parameterType="Optional",            direction="Input")        proj_name = arcpy.Parameter(            displayName="Project Name",            name="proj_name",            datatype="GPString",            parameterType="Required",            direction="Input")        proj_num = arcpy.Parameter(            displayName="Project Number",            name="proj_num",            datatype="LONG",            parameterType="Required",            direction="Input")        proj_num.filter.type = "Range"        proj_num.filter.list = ["10000", "99999"]        year = arcpy.Parameter(            displayName="Year",            name="year",            datatype="LONG",            parameterType="Required",            direction="Input")        program = arcpy.Parameter(            displayName="Program",            name="out_program_tax_features",            datatype="GPString",            parameterType="Required",            direction="Input")        # create multivalue list for program_name        program.filter.list = ['Parks With Purpose', 'Working Farms Fund', 'Working Forest Fund', 'Conservation Acquisition']        parameters = [in_features, temp_tax_layer,  proj_name, proj_num, year, program, program_boundary_layer, program_tax_layer,]        return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        # retrieve parameters        in_features = parameters[0].valueAsText        temp_tax_layer = parameters[1].valueAsText        proj_name = parameters[2].valueAsText        proj_num = parameters[3].valueAsText        year = parameters[4].valueAsText        program = parameters[5].valueAsText        program_boundary_layer = parameters[6].valueAsText        program_tax_layer = parameters[7].valueAsText        # collect user        user = expanduser("~")        user = user[9:]        # core logic        coreLogic = r"C:\Users\%s\The Conservation Fund\CoreLogicParcels - Documents" % user        # counties layer        counties = r"C:\Users\%s\The Conservation Fund\Esri GIS Users - Documents\General\GIS\Counties\tl_2021_us_county.shp" % user        states = r"C:\Users\%s\The Conservation Fund\Esri GIS Users - Documents\General\GIS\U.S Geography and Census Data\State Boundaries Shapefiles\tl_2021_us_state.shp" % user        # get the states the layer is in        states = arcpy.management.SelectLayerByLocation(states, "INTERSECT", in_features, None,                                                             "NEW_SELECTION", "NOT_INVERT")        # get the counties the layer is in        counties = arcpy.management.SelectLayerByLocation(counties, "INTERSECT", in_features, None, "NEW_SELECTION",                                                                "NOT_INVERT")        def getTaxParcels():            arr = arcpy.da.TableToNumPyArray(counties, ('NAME', 'STATEFP', 'COUNTYFP'))            df = pd.DataFrame(arr)            df.reset_index()            taxParcels = []            for row in range(len(df)):                stateFIPS = int(df.loc[row, 'STATEFP'])  # pull out state FIPS                countyFIPS = int(df.loc[row, 'COUNTYFP'])  # pull out county FIPS                # add a 0 to state fips if it's a single digit to match the corelogic database                if stateFIPS < 10:                    stateFIPS = "0" + str(stateFIPS)                else:                    stateFIPS = str(stateFIPS)                # add two 0s to county fips if it's a double digit to match the corelogic database                # add one 0 to county fips if it's a single digit to match the corelogic database                if (countyFIPS < 100) & (countyFIPS >= 10):                    countyFIPS = "0" + str(countyFIPS)                elif countyFIPS < 10:                    countyFIPS = "00" + str(countyFIPS)                else:                    countyFIPS = str(countyFIPS)                # select the tax parcels from the CoreLogic folder                Selected_County = r"%s\%s\%s%s_parcel.shp" % (coreLogic, stateFIPS, stateFIPS, countyFIPS)                taxParcels.append(Selected_County)            return taxParcels        # get the project tax parcels, merge them, and clip them        toMerge = getTaxParcels()        merge = arcpy.management.Merge(toMerge, temp_tax_layer)        parcels = arcpy.analysis.Clip(merge, in_features, "Temporary_Tax_Parcels")        # create dataframe from the state its in and pull out the state name        arr = arcpy.da.TableToNumPyArray(states, 'NAME')        df = pd.DataFrame(arr)        proj_states = []        for row in range(len(df)):            if str(df.loc[row, 'NAME']) not in proj_states:                proj_states.append(str(df.loc[row, 'NAME']))                arcpy.analysis.Select(states, df.loc[row, 'NAME'],                                      "NAME = '%s'" % df.loc[row, 'NAME'])            else:                pass        # tax parcel geoprocessing steps - adding fields and populating them with the inputs        for state in proj_states:            parcels = arcpy.management.SelectLayerByLocation(parcels, "INTERSECT", state)            arcpy.management.DeleteField(parcels, "STATE")            arcpy.management.CalculateField(parcels, "Proj_Name", '"%s"' % proj_name, "PYTHON3")            arcpy.management.CalculateField(parcels, "Proj_Num", '"%s"' % proj_num, "PYTHON3")            arcpy.management.CalculateField(parcels, "Year", '"%s"' % year, "PYTHON3")            arcpy.management.CalculateField(parcels, "Program", '"%s"' % program, "PYTHON3")            arcpy.management.CalculateField(parcels, "State", '"%s"' % str(state), 'PYTHON3')            arcpy.management.CalculateGeometryAttributes(parcels, [["Acres", 'AREA']], '', "ACRES", 'PROJCS["USA_Contiguous_Albers_Equal_Area_Conic_USGS_version",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Albers"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-96.0],PARAMETER["Standard_Parallel_1",29.5],PARAMETER["Standard_Parallel_2",45.5],PARAMETER["Latitude_Of_Origin",23.0],UNIT["Meter",1.0]]', "SAME_AS_INPUT")            # buffer steps - create buffer, clip and remove overlap with in_features to get perimeter, join w/ parcels, and create in/out field            buffer = arcpy.analysis.Buffer(parcels, "Temporary_Buffer", "100 FeetInt", "FULL", "ROUND", "NONE", None, "PLANAR")            arcpy.management.Dissolve(buffer, "Temporary_Buffer_Dissolve", None, None, "MULTI_PART", "DISSOLVE_LINES", '')            perimeter = arcpy.analysis.Erase("Temporary_Buffer_Dissolve", in_features, "Perimeter", None)            arcpy.analysis.Intersect([perimeter, merge], "Perimeter_Parcels", "ALL", None, "INPUT")            pp = arcpy.management.CalculateField("Perimeter_Parcels", "Parcel_Loc", '"Outside Boundary"', "PYTHON3", '', "TEXT",                                            "NO_ENFORCE_DOMAINS")            arcpy.management.CalculateField(parcels, "Parcel_Loc", '"Inside Boundary"', "PYTHON3", '', "TEXT", "NO_ENFORCE_DOMAINS")            new_parcels = arcpy.analysis.Union([pp, parcels], "Project_Parcels")            arcpy.management.DeleteField(new_parcels, "BUFF_DIST;ORIG_FID;PARCEL_ID_1;STATE_CODE_1;CNTY_CODE_1;APN_1;APN2_1;OWNER_1;ADDR_1;CITY_1;STATE_1;ZIP_1;PLUS_1;STD_ADDR_1;STD_CITY_1;STD_STATE_1;STD_ZIP_1;STD_PLUS_1;Shape_Length_1;Shape_Area_1;FID_Temporary_Tax_Parcels;PARCEL_ID_12;STATE_CODE_12;CNTY_CODE_12;APN_12;APN2_12;OWNER_12;ADDR_12;CITY_12;ZIP_12;PLUS_12;STD_ADDR_12;STD_CITY_12;STD_STATE_12;STD_ZIP_12;STD_PLUS_12;Proj_Name_1;Proj_Num_1;Year_1;Program_1;Acres_1;Parcel_Loc_1;State_12", "DELETE_FIELDS")            # append to program tax parcel feature layer            if parameters[7].altered:                arcpy.management.Append(new_parcels, program_tax_layer, "NO_TEST", None, '', '')            # project boundary geoprocessing steps - dissolve tax parcels (without perimeter parcels) on those 6 fields            temp_pb = arcpy.management.Dissolve(parcels, "Temporary_Project_Boundary", ["Proj_Name", "Proj_Num", "Year", "Program", "State"], None, "", "DISSOLVE_LINES", '')            arcpy.management.CalculateGeometryAttributes("Temporary_Project_Boundary", [["Acres", 'AREA']], '', "ACRES", 'PROJCS["USA_Contiguous_Albers_Equal_Area_Conic_USGS_version",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Albers"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-96.0],PARAMETER["Standard_Parallel_1",29.5],PARAMETER["Standard_Parallel_2",45.5],PARAMETER["Latitude_Of_Origin",23.0],UNIT["Meter",1.0]]', "SAME_AS_INPUT")            # append it to program project boundary layer            if parameters[6].altered:                def getlastid():                    cursor = arcpy.UpdateCursor(program_boundary_layer)                    ids = sorted([row.getValue("ID") for row in cursor])                    return int(ids[-1])                def SequentialNumber(id):                    pStart = 1                    pInterval = 1                    if (id == 0):                        id = pStart                    else:                        id = id + pInterval                    return id                id = getlastid()                arcpy.management.CalculateField(temp_pb, "ID", SequentialNumber(id), "PYTHON3")                arcpy.management.Append(temp_pb, program_boundary_layer, "NO_TEST", None, '', '')    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return
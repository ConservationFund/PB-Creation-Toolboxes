# -*- coding: utf-8 -*-import arcpyimport osfrom os.path import expanduser, existsimport pandasclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [Tool]class Tool(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Create and Upload Project Boundary"        self.description = "A toolbox that takes your selected tax parcels, dissolves them, and uploads them to your program's boundary and feature layers, as well as State/Year layers in the ESRI GIS Users Sharepoint."        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        in_features = arcpy.Parameter(            displayName="Input Features",            name="in_features",            datatype="GPFeatureLayer",            parameterType="Required",            direction="Input")        in_features.displayOrder = 0        proj_name = arcpy.Parameter(            displayName="Project Name",            name="proj_name",            datatype="GPString",            parameterType="Required",            direction="Input")        proj_name.displayOrder = 1        proj_num = arcpy.Parameter(            displayName="Project Number",            name="proj_num",            datatype="LONG",            parameterType="Required",            direction="Input")        proj_num.filter.type = "Range"        proj_num.filter.list = ["10000", "99999"]        proj_num.displayOrder = 2        year = arcpy.Parameter(            displayName="Year",            name="year",            datatype="LONG",            parameterType="Required",            direction="Input")        year.displayOrder = 3        status = arcpy.Parameter(            displayName="Status",            name="Status",            datatype="GPString",            parameterType="Required",            direction="Input")        status.filter.list = ['Acquired/Holding', 'Committee Approval', 'Completed/Assisted', 'Completed/Conveyed',                              'Inactive', 'Initiation', 'Under Contract']        status.displayOrder = 4        program = arcpy.Parameter(            displayName="Program",            name="out_program_tax_features",            datatype="GPString",            parameterType="Required",            direction="Input")        program.displayOrder = 5        program_boundary_layer = arcpy.Parameter(            displayName="Output Project Boundary Feature Layer",            name="out_pb_features",            datatype="GPFeatureLayer",            parameterType="Optional",            direction="Input")        # create multivalue list for program_name        program.filter.list = ['Parks With Purpose', 'Working Farms Fund', 'Working Forest Fund',                               'Conservation Acquisition']        program_boundary_layer.displayOrder = 6        program_tax_layer = arcpy.Parameter(            displayName="Output Boundary Parcels Feature Layer",            name="out_tax_parcels",            datatype="GPFeatureLayer",            parameterType="Optional",            direction="Input")        program_tax_layer.displayOrder = 7        temp_tax_layer = arcpy.Parameter(            displayName="Temporary Tax Parcels Layer",            name="temp_tax_features",            datatype="GPFeatureLayer",            parameterType="Derived",            direction="Output")        parameters = [in_features, temp_tax_layer, proj_name, proj_num, year, program, program_boundary_layer,                      program_tax_layer, status]        return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        proj_num = parameters[6]        if parameters[5].altered: # if acquisition has been selected            proj_num.enabled = True        else:            proj_num.enabled = False        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        # retrieve parameters        in_features = parameters[0].valueAsText        temp_tax_layer = parameters[1].valueAsText        proj_name = parameters[2].valueAsText        proj_num = parameters[3].valueAsText        year = parameters[4].valueAsText        program = parameters[5].valueAsText        program_boundary_layer = parameters[6].valueAsText        program_tax_layer = parameters[7].valueAsText        status = parameters[8].valueAsText        # collect user        user = expanduser("~")        user = user[9:]        # counties layer        counties = r"C:\Users\%s\The Conservation Fund\Esri GIS Users - Documents\GIS\Counties\tl_2021_us_county.shp" % user        # states layer        states = r"C:\Users\%s\The Conservation Fund\Esri GIS Users - Documents\GIS\U.S Geography and Census Data\State Boundaries Shapefiles\tl_2021_us_state.shp" % user        # get the state the layer is in        states = arcpy.management.MakeFeatureLayer(states, "states")        arcpy.management.SelectLayerByLocation(states, "INTERSECT", in_features, None, "NEW_SELECTION", "NOT_INVERT")        # create dataframe from the state its in and pull out the state name        arr = arcpy.da.TableToNumPyArray(states, 'NAME')        df = pandas.DataFrame(arr)        df.reset_index()        state = []        for row in range(len(df)):            state.append(str(df.loc[row, 'NAME']))        # tax parcel geoprocessing steps - adding fields and populating them with the inputs        for state in state:            project_parcels = arcpy.conversion.FeatureClassToFeatureClass(in_features, temp_tax_layer, "Project_Parcels")            arcpy.management.DeleteField(project_parcels, "STATE", "DELETE_FIELDS")            arcpy.management.CalculateField(project_parcels, "Proj_Name", '"%s"' % proj_name, "PYTHON3")            arcpy.management.CalculateField(project_parcels, "Proj_Num", '"%s"' % proj_num, "PYTHON3")            arcpy.management.CalculateField(project_parcels, "Year", '"%s"' % year, "PYTHON3")            arcpy.management.CalculateField(project_parcels, "Program", '"%s"' % program, "PYTHON3")            arcpy.management.CalculateField(project_parcels, "State", '"%s"' % state, "PYTHON3")            arcpy.management.CalculateField(project_parcels, 'Status', '"%s"' % status, 'PYTHON3')            arcpy.management.CalculateGeometryAttributes(project_parcels, [["Acres", 'AREA']], '', "ACRES", 'PROJCS["USA_Contiguous_Albers_Equal_Area_Conic_USGS_version",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Albers"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-96.0],PARAMETER["Standard_Parallel_1",29.5],PARAMETER["Standard_Parallel_2",45.5],PARAMETER["Latitude_Of_Origin",23.0],UNIT["Meter",1.0]]', "SAME_AS_INPUT")            # append to program tax parcel feature layer            if parameters[8].altered:                arcpy.management.Append(project_parcels, program_tax_layer, "NO_TEST", None, '', '')            # project boundary geoprocessing steps - dissolve tax parcels on those 6 fields            temp_pb = arcpy.management.Dissolve(project_parcels, "Project_Boundary",            "Proj_Name;Year;Proj_Num;Program;State;Status", None, "MULTI_PART", "DISSOLVE_LINES", '')            arcpy.management.CalculateGeometryAttributes("Project_Boundary", [["Acres", 'AREA']], '', "ACRES", 'PROJCS["USA_Contiguous_Albers_Equal_Area_Conic_USGS_version",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Albers"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-96.0],PARAMETER["Standard_Parallel_1",29.5],PARAMETER["Standard_Parallel_2",45.5],PARAMETER["Latitude_Of_Origin",23.0],UNIT["Meter",1.0]]', "SAME_AS_INPUT")            # append it to program project boundary layer            if parameters[8].altered:                arcpy.management.Append("Project_Boundary", program_boundary_layer, "NO_TEST", None, '', '')            if parameters[7].altered:                def getlastid():                    cursor = arcpy.SearchCursor(program_boundary_layer)                    ids = sorted([row.getValue("ID") for row in cursor])                    return int(ids[-1])                def SequentialNumber(id):                    pStart = 1                    pInterval = 1                    if (id == 0):                        id = pStart                    else:                        id = id + pInterval                    return id                id = getlastid()                arcpy.management.CalculateField(temp_pb, "ID", SequentialNumber(id), "PYTHON3")                arcpy.management.Append(temp_pb, program_boundary_layer, "NO_TEST", None, '', '')    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return